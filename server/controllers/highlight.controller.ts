// server/controllers/highlight.controller.ts

import { Request, Response } from 'express';
import { db } from '../db';
// ‚úÖ 1. Importar a tabela 'promotions' do schema
import { stores, products, highlightImpressions, highlightConfigurations, promotions } from '../../shared/schema';
import { eq, and, gte, lte, desc, sql } from 'drizzle-orm';

/**
 * Buscar produtos em destaque para a home
 * Implementa algoritmo de distribui√ß√£o justa E DADOS DE PROMO√á√ÉO
 */
export const getHomeHighlights = async (req: Request, res: Response) => {
  try {
    console.log('üîç [Highlights] Buscando produtos em destaque...');
    const now = new Date(); // Usado para buscar apenas promo√ß√µes ativas

    // üéØ EXTRAIR DADOS DO REQUEST PARA PERSONALIZA√á√ÉO (FUTURO)
    const userId = req.user?.id || null;
    const categoryFilter = req.query.category as string || null;

    console.log('üéØ [Highlights] Par√¢metros:', {
      userId,
      categoryFilter
    });

    // 1. Buscar configura√ß√µes de destaque por plano (Sua l√≥gica original)
    const configs = await db.select().from(highlightConfigurations).where(eq(highlightConfigurations.isActive, true));

    if (configs.length === 0) {
      return res.json({ success: true, highlights: {}, message: 'Nenhuma configura√ß√£o de destaque encontrada' });
    }

    // ‚úÖ 2. QUERY PRINCIPAL - APENAS CAMPOS QUE EXISTEM
    const storesWithProducts = await db.select({
      storeId: stores.id,
      storeName: stores.name,
      subscriptionPlan: stores.subscriptionPlan,
      isInTrial: stores.isInTrial,
      highlightWeight: stores.highlightWeight,
      lastHighlightedAt: stores.lastHighlightedAt,
      totalImpressions: stores.totalHighlightImpressions,
      // ‚úÖ INCLUIR location da loja para futuras funcionalidades
      storeLocation: stores.location,
      productId: products.id,
      productName: products.name,
      productPrice: products.price,
      productCategory: products.category,
      productCreatedAt: products.createdAt,
      images: products.images,
      // CAMPOS DA PROMO√á√ÉO (ser√£o null se n√£o houver promo√ß√£o ativa)
      promotionType: promotions.type,
      discountPercentage: promotions.discountPercentage,
      promotionEndTime: promotions.endTime
    })
    .from(stores)
    .innerJoin(products, eq(products.storeId, stores.id))
    // O LEFT JOIN garante que produtos sem promo√ß√£o ainda sejam inclu√≠dos.
    .leftJoin(
        promotions,
        and(
            eq(promotions.productId, products.id),
            // Condi√ß√£o para garantir que a promo√ß√£o est√° ATIVA
            lte(promotions.startTime, now),
            gte(promotions.endTime, now)
        )
    )
    .where(and(
      eq(products.isActive, true),
      eq(stores.isOpen, true),
      // üéØ FILTRO POR CATEGORIA se especificado
      categoryFilter ? eq(products.category, categoryFilter) : sql`true`
    ))
    .orderBy(desc(products.createdAt));

    console.log(`üîç [Highlights] Encontradas ${storesWithProducts.length} combina√ß√µes loja-produto`);

    // ‚úÖ 3. PROCESSAMENTO DE DADOS - REMOVIDAS FUNCIONALIDADES DE LOCALIZA√á√ÉO PROBLEM√ÅTICAS
    const processedProducts = storesWithProducts.map(item => {
        let discountedPrice = null;
        if (item.discountPercentage && item.productPrice) {
            const discount = item.productPrice * (item.discountPercentage / 100);
            discountedPrice = Math.round((item.productPrice - discount) * 100) / 100;
        }

        return {
            ...item,
            discountedPrice // Adiciona a propriedade ao objeto do produto
        };
    });

    // 4. Agrupar por plano e aplicar algoritmo de distribui√ß√£o
    const highlightsBySection: Record<string, any[]> = {};

    for (const config of configs) {
      const planType = config.planType;
      const sections = config.sections || [];

      // A filtragem agora opera sobre os produtos j√° processados
      let planProducts = processedProducts.filter(item => {
        if (planType === 'trial') {
          return item.isInTrial === true;
        }
        return item.subscriptionPlan === planType;
      });

      // ‚úÖ Se a se√ß√£o for 'ofertas_especiais', priorizamos produtos que REALMENTE t√™m desconto
      if (sections.includes('ofertas_especiais')) {
          const promoProducts = planProducts.filter(p => p.discountedPrice !== null);
          const regularProducts = planProducts.filter(p => p.discountedPrice === null);
          planProducts = [...promoProducts, ...regularProducts]; // Produtos em promo√ß√£o primeiro
      }

      console.log(`üîç [Highlights] Plano ${planType}: ${planProducts.length} produtos`);

      // Aplicar algoritmo de peso
      planProducts = planProducts.map(item => {
        const baseWeight = item.highlightWeight || 1;
        const impressionPenalty = item.totalImpressions ? Math.min(item.totalImpressions / 1000, 0.5) : 0;
        const finalWeight = Math.max(baseWeight - impressionPenalty, 0.1);

        return { 
          ...item, 
          calculatedWeight: finalWeight
        };
      });

      planProducts.sort((a, b) => {
        // Usar lastHighlightedAt diretamente do banco
        const aLastHighlighted = a.lastHighlightedAt ? new Date(a.lastHighlightedAt).getTime() : 0;
        const bLastHighlighted = b.lastHighlightedAt ? new Date(b.lastHighlightedAt).getTime() : 0;
        const timeDiff = aLastHighlighted - bLastHighlighted;
        if (Math.abs(timeDiff) > 6 * 60 * 60 * 1000) {
          return aLastHighlighted - bLastHighlighted;
        }
        return (b as any).calculatedWeight - (a as any).calculatedWeight;
      });

      for (const section of sections) {
        if (!highlightsBySection[section]) {
          highlightsBySection[section] = [];
        }
        const sectionLimit = getSectionLimit(section, planType);
        const sectionProducts = planProducts.slice(0, sectionLimit);
        highlightsBySection[section].push(...sectionProducts);
      }
    }

    // 5. Finalizar se√ß√µes com limites e diversifica√ß√£o
    const finalHighlights: Record<string, any[]> = {};
    for (const [section, products] of Object.entries(highlightsBySection)) {
      const diversified = diversifyProducts(products);
      const maxItems = getMaxItemsPerSection(section);
      finalHighlights[section] = diversified.slice(0, maxItems);
    }

    console.log('‚úÖ [Highlights] Distribui√ß√£o final:', Object.keys(finalHighlights).map(k => `${k}: ${finalHighlights[k].length}`));

    res.json({
      success: true,
      highlights: finalHighlights,
      totalSections: Object.keys(finalHighlights).length
    });

  } catch (error) {
    console.error('‚ùå [Highlights] Erro ao buscar destaques:', error);
    res.status(500).json({ success: false, error: 'Erro ao buscar produtos em destaque', highlights: {} });
  }
};

/**
* Registrar impress√£o de destaque
* Anti-spam: m√°ximo 1 impress√£o por IP por produto a cada 5 minutos
*/
export const recordHighlightImpression = async (req: Request, res: Response) => {
try {
const { storeId, productId, section } = req.body;
const userId = req.user?.id || null;
const ipAddress = req.ip || (req as any).connection?.remoteAddress || null;

if (!storeId || !section) {
return res.status(400).json({
success: false,
error: 'storeId e section s√£o obrigat√≥rios'
});
}

// ‚úÖ CORRIGIDO: Converter storeId para number explicitamente
const numericStoreId = Number(storeId);
if (isNaN(numericStoreId)) {
  return res.status(400).json({
    success: false,
    error: 'storeId deve ser um n√∫mero v√°lido'
  });
}

// Verificar spam: mesma impress√£o nos √∫ltimos 5 minutos
const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

const recentImpression = await db.select()
.from(highlightImpressions)
.where(and(
eq(highlightImpressions.storeId, numericStoreId),
productId ? eq(highlightImpressions.productId, Number(productId)) : sql`product_id IS NULL`,
eq(highlightImpressions.section, section),
gte(highlightImpressions.timestamp, fiveMinutesAgo),
// ‚úÖ CORRIGIDO: Verificar ipAddress antes de usar
ipAddress ? eq(highlightImpressions.ipAddress, ipAddress) : sql`ip_address IS NULL`
))
.limit(1);

if (recentImpression.length > 0) {
return res.json({
success: true,
message: 'Impress√£o j√° registrada recentemente'
});
}

// Registrar nova impress√£o
await db.insert(highlightImpressions).values({
storeId: numericStoreId,
productId: productId ? Number(productId) : null,
section,
userId,
ipAddress
});

// Atualizar contador na loja
await db.update(stores)
.set({
totalHighlightImpressions: sql`${stores.totalHighlightImpressions} + 1`,
lastHighlightedAt: sql`NOW()`
})
.where(eq(stores.id, numericStoreId));

res.json({
success: true,
message: 'Impress√£o registrada com sucesso'
});

} catch (error) {
console.error('‚ùå [Highlights] Erro ao registrar impress√£o:', error);
res.status(500).json({
success: false,
error: 'Erro ao registrar impress√£o'
});
}
};

/**
* Analytics de destaque para lojistas
*/
export const getHighlightAnalytics = async (req: Request, res: Response) => {
try {
const { storeId } = req.params;
const { days = 30 } = req.query;

// ‚úÖ CORRIGIDO: Validar storeId
const numericStoreId = Number(storeId);
if (isNaN(numericStoreId)) {
  return res.status(400).json({
    success: false,
    error: 'storeId deve ser um n√∫mero v√°lido'
  });
}

const daysAgo = new Date(Date.now() - Number(days) * 24 * 60 * 60 * 1000);

const impressions = await db.select({
section: highlightImpressions.section,
date: sql<string>`DATE(${highlightImpressions.timestamp})`,
count: sql<number>`COUNT(*)::int`
})
.from(highlightImpressions)
.where(and(
eq(highlightImpressions.storeId, numericStoreId),
gte(highlightImpressions.timestamp, daysAgo)
))
.groupBy(highlightImpressions.section, sql`DATE(${highlightImpressions.timestamp})`)
.orderBy(sql`DATE(${highlightImpressions.timestamp})`);

res.json({
success: true,
analytics: impressions,
period: `${days} dias`
});

} catch (error) {
console.error('‚ùå [Highlights] Erro ao buscar analytics:', error);
res.status(500).json({
success: false,
error: 'Erro ao buscar analytics de destaque'
});
}
};

/**
* Atualizar peso de destaque (admin)
*/
export const updateHighlightWeight = async (req: Request, res: Response) => {
try {
const { storeId } = req.params;
const { weight } = req.body;

// ‚úÖ CORRIGIDO: Validar storeId
const numericStoreId = Number(storeId);
if (isNaN(numericStoreId)) {
  return res.status(400).json({
    success: false,
    error: 'storeId deve ser um n√∫mero v√°lido'
  });
}

if (typeof weight !== 'number' || weight < 0 || weight > 10) {
return res.status(400).json({
success: false,
error: 'Peso deve ser um n√∫mero entre 0 e 10'
});
}

await db.update(stores)
.set({ highlightWeight: weight })
.where(eq(stores.id, numericStoreId));

res.json({
success: true,
message: 'Peso de destaque atualizado com sucesso'
});

} catch (error) {
console.error('‚ùå [Highlights] Erro ao atualizar peso:', error);
res.status(500).json({
success: false,
error: 'Erro ao atualizar peso de destaque'
});
}
};

// ===== FUN√á√ïES AUXILIARES =====

function getSectionLimit(section: string, planType: string): number {
const limits: Record<string, Record<string, number>> = {
'em_destaque_premium': { premium: 10, pro: 0, start: 0, freemium: 0, trial: 0 },
'ofertas_especiais': { premium: 8, pro: 6, start: 0, freemium: 0, trial: 3 },
'novidades': { premium: 6, pro: 4, start: 3, freemium: 0, trial: 2 },
'descobrir_lojas_locais': { premium: 3, pro: 2, start: 2, freemium: 2, trial: 1 },
'testando_premium': { premium: 0, pro: 0, start: 0, freemium: 0, trial: 5 }
};

return limits[section]?.[planType] || 0;
}

function getMaxItemsPerSection(section: string): number {
const maxItems: Record<string, number> = {
'em_destaque_premium': 15,
'ofertas_especiais': 12,
'novidades': 10,
'descobrir_lojas_locais': 8,
'testando_premium': 6
};

return maxItems[section] || 10;
}

function diversifyProducts(products: any[]): any[] {
const diversified: any[] = [];
const usedStores = new Set<number>();
const usedCategories = new Set<string>();

// Primeira passada: diversificar por loja
for (const product of products) {
if (!usedStores.has(product.storeId)) {
diversified.push(product);
usedStores.add(product.storeId);
usedCategories.add(product.productCategory);
}
}

// Segunda passada: adicionar produtos de categorias diferentes
for (const product of products) {
if (diversified.length >= getMaxItemsPerSection('descobrir_lojas_locais')) break;

if (!diversified.find(p => p.productId === product.productId) && 
!usedCategories.has(product.productCategory)) {
diversified.push(product);
usedCategories.add(product.productCategory);
}
}

// Terceira passada: completar com produtos restantes
for (const product of products) {
if (diversified.length >= getMaxItemsPerSection('descobrir_lojas_locais')) break;

if (!diversified.find(p => p.productId === product.productId)) {
diversified.push(product);
}
}

return diversified;
}