// ==========================================================================
// SOLUÇÃO COMPLETA PARA EXIBIÇÃO SEGURA DE IMAGENS
// ==========================================================================
//
// Esta solução resolve definitivamente o problema de segurança na 
// exibição de imagens de produtos nas páginas de reservas, lista de desejos
// e outras partes do aplicativo, garantindo que:
//
// 1. Imagens sejam sempre acessadas por APIs seguras, não por caminhos diretos
// 2. Isolamento adequado entre lojas e seus dados
// 3. Tratamento de erros consistente
// 4. Suporte a múltiplas imagens quando necessário
//
// ==========================================================================

// ==========================================================================
// 1. CONTROLLER DE IMAGENS - BACKEND
// ==========================================================================

// Arquivo: server/controllers/image.controller.js
import { db } from '../db';
import fs from 'fs';
import path from 'path';

/**
 * @route GET /api/products/:id/primary-image
 * @desc Retorna a imagem principal de um produto de forma segura
 * @access Público
 */
export const getProductPrimaryImage = async (req, res) => {
  try {
    const productId = parseInt(req.params.id);
    
    if (isNaN(productId)) {
      return res.status(400).redirect('/placeholder-image.jpg');
    }
    
    // Buscar informações do produto para verificação de existência
    const productQuery = `
      SELECT p.id, p.store_id
      FROM products p
      WHERE p.id = $1
    `;
    
    const productResult = await db.query(productQuery, [productId]);
    
    if (!productResult.rows.length) {
      console.error(`Produto não encontrado: ${productId}`);
      return res.redirect('/placeholder-image.jpg');
    }
    
    // Buscar a imagem principal do produto
    const imageQuery = `
      SELECT pi.image_url, pi.thumbnail_url
      FROM product_images pi
      WHERE pi.product_id = $1 AND pi.is_primary = true
      ORDER BY pi.display_order ASC, pi.id DESC
      LIMIT 1
    `;
    
    const imageResult = await db.query(imageQuery, [productId]);
    
    // Se não houver imagem principal, verificar qualquer imagem
    if (!imageResult.rows.length) {
      const fallbackQuery = `
        SELECT pi.image_url, pi.thumbnail_url
        FROM product_images pi
        WHERE pi.product_id = $1
        ORDER BY pi.id DESC
        LIMIT 1
      `;
      
      const fallbackResult = await db.query(fallbackQuery, [productId]);
      
      if (!fallbackResult.rows.length) {
        console.log(`Nenhuma imagem encontrada para produto ${productId}`);
        return res.redirect('/placeholder-image.jpg');
      }
      
      // Usar a primeira imagem disponível
      return res.redirect(fallbackResult.rows[0].image_url);
    }
    
    // Redirecionar para a URL da imagem
    res.redirect(imageResult.rows[0].image_url);
  } catch (error) {
    console.error('Erro ao buscar imagem principal do produto:', error);
    res.redirect('/placeholder-image.jpg');
  }
};

/**
 * @route GET /api/products/:id/thumbnail
 * @desc Retorna a thumbnail da imagem principal de um produto
 * @access Público
 */
export const getProductThumbnail = async (req, res) => {
  try {
    const productId = parseInt(req.params.id);
    
    if (isNaN(productId)) {
      return res.status(400).redirect('/placeholder-image.jpg');
    }
    
    // Buscar a thumbnail da imagem principal
    const query = `
      SELECT pi.thumbnail_url
      FROM product_images pi
      WHERE pi.product_id = $1 AND pi.is_primary = true
      ORDER BY pi.display_order ASC, pi.id DESC
      LIMIT 1
    `;
    
    const result = await db.query(query, [productId]);
    
    if (!result.rows.length) {
      // Fallback para qualquer thumbnail
      const fallbackQuery = `
        SELECT pi.thumbnail_url
        FROM product_images pi
        WHERE pi.product_id = $1
        ORDER BY pi.id DESC
        LIMIT 1
      `;
      
      const fallbackResult = await db.query(fallbackQuery, [productId]);
      
      if (!fallbackResult.rows.length) {
        return res.redirect('/placeholder-image.jpg');
      }
      
      return res.redirect(fallbackResult.rows[0].thumbnail_url);
    }
    
    res.redirect(result.rows[0].thumbnail_url);
  } catch (error) {
    console.error('Erro ao buscar thumbnail do produto:', error);
    res.redirect('/placeholder-image.jpg');
  }
};

/**
 * @route GET /api/products/:id/images
 * @desc Retorna todas as imagens de um produto
 * @access Público
 */
export const getProductImages = async (req, res) => {
  try {
    const productId = parseInt(req.params.id);
    
    if (isNaN(productId)) {
      return res.status(400).json({ 
        success: false, 
        message: 'ID de produto inválido' 
      });
    }
    
    // Buscar produto para verificar existência
    const productQuery = `
      SELECT p.id, p.name, p.store_id
      FROM products p
      WHERE p.id = $1
    `;
    
    const productResult = await db.query(productQuery, [productId]);
    
    if (!productResult.rows.length) {
      return res.status(404).json({
        success: false,
        message: 'Produto não encontrado'
      });
    }
    
    // Buscar todas as imagens do produto, ordenadas por prioridade
    const imagesQuery = `
      SELECT 
        pi.id,
        pi.image_url,
        pi.thumbnail_url,
        pi.is_primary,
        pi.display_order
      FROM 
        product_images pi
      WHERE 
        pi.product_id = $1
      ORDER BY 
        pi.is_primary DESC,
        pi.display_order ASC,
        pi.id ASC
    `;
    
    const imagesResult = await db.query(imagesQuery, [productId]);
    
    return res.json({
      success: true,
      product: {
        id: productId,
        name: productResult.rows[0].name,
        store_id: productResult.rows[0].store_id
      },
      images: imagesResult.rows || []
    });
  } catch (error) {
    console.error('Erro ao buscar imagens do produto:', error);
    return res.status(500).json({
      success: false,
      message: 'Erro ao buscar imagens do produto'
    });
  }
};

/**
 * @route GET /api/products/:id/image/:imageId
 * @desc Retorna uma imagem específica de um produto
 * @access Público
 */
export const getProductImage = async (req, res) => {
  try {
    const productId = parseInt(req.params.id);
    const imageId = parseInt(req.params.imageId);
    
    if (isNaN(productId) || isNaN(imageId)) {
      return res.status(400).redirect('/placeholder-image.jpg');
    }
    
    // Buscar a imagem específica, garantindo que pertence ao produto
    const query = `
      SELECT pi.image_url
      FROM product_images pi
      WHERE pi.product_id = $1 AND pi.id = $2
    `;
    
    const result = await db.query(query, [productId, imageId]);
    
    if (!result.rows.length) {
      console.log(`Imagem ${imageId} não encontrada para produto ${productId}`);
      return res.redirect('/placeholder-image.jpg');
    }
    
    res.redirect(result.rows[0].image_url);
  } catch (error) {
    console.error('Erro ao buscar imagem específica:', error);
    res.redirect('/placeholder-image.jpg');
  }
};

/**
 * @route GET /api/promotions/:id/image
 * @desc Retorna a imagem de uma promoção (usando a imagem do produto)
 * @access Público
 */
export const getPromotionImage = async (req, res) => {
  try {
    const promotionId = parseInt(req.params.id);
    
    if (isNaN(promotionId)) {
      return res.status(400).redirect('/placeholder-image.jpg');
    }
    
    // Buscar o ID do produto associado à promoção
    const promotionQuery = `
      SELECT product_id
      FROM promotions
      WHERE id = $1
    `;
    
    const promotionResult = await db.query(promotionQuery, [promotionId]);
    
    if (!promotionResult.rows.length) {
      console.error(`Promoção não encontrada: ${promotionId}`);
      return res.redirect('/placeholder-image.jpg');
    }
    
    const productId = promotionResult.rows[0].product_id;
    
    // Redirecionar para a API de imagem do produto
    res.redirect(`/api/products/${productId}/primary-image`);
  } catch (error) {
    console.error('Erro ao buscar imagem da promoção:', error);
    res.redirect('/placeholder-image.jpg');
  }
};

// ==========================================================================
// 2. ROTAS DE API - BACKEND
// ==========================================================================

// Arquivo: server/routes/api.js
import express from 'express';
import { 
  getProductPrimaryImage, 
  getProductThumbnail, 
  getProductImages, 
  getProductImage,
  getPromotionImage
} from '../controllers/image.controller.js';

const router = express.Router();

// Rotas de imagens de produtos
router.get('/products/:id/primary-image', getProductPrimaryImage);
router.get('/products/:id/thumbnail', getProductThumbnail);
router.get('/products/:id/images', getProductImages);
router.get('/products/:id/image/:imageId', getProductImage);

// Rotas de imagens de promoções
router.get('/promotions/:id/image', getPromotionImage);

export default router;

// ==========================================================================
// 3. COMPONENTE SEGURO DE IMAGEM - FRONTEND
// ==========================================================================

// Arquivo: client/src/components/SafeImage.jsx
import React, { useState } from 'react';

/**
 * Componente seguro para exibição de imagens
 * Sempre usa APIs seguras em vez de caminhos diretos de arquivo
 */
const SafeImage = ({ 
  productId, 
  promotionId,
  imageId,
  alt = '', 
  className = "w-full h-full object-cover",
  onError = null,
  placeholderImage = "/placeholder-image.jpg"
}) => {
  const [error, setError] = useState(false);

  // Determinar a URL da imagem com base nos parâmetros
  let src;
  
  if (promotionId) {
    // Imagem de promoção
    src = `/api/promotions/${promotionId}/image`;
  } else if (productId) {
    if (imageId) {
      // Imagem específica de um produto
      src = `/api/products/${productId}/image/${imageId}`;
    } else {
      // Imagem principal do produto
      src = `/api/products/${productId}/primary-image`;
    }
  } else {
    // Sem parâmetros válidos, usar placeholder
    src = placeholderImage;
  }
  
  // Handler para erros de carregamento de imagem
  const handleError = (e) => {
    if (!error) {
      console.warn(`Erro ao carregar imagem: ${src}`);
      setError(true);
      e.currentTarget.src = placeholderImage;
      
      if (onError && typeof onError === 'function') {
        onError(e);
      }
    }
  };
  
  return (
    <img
      src={error ? placeholderImage : src}
      alt={alt}
      className={className}
      onError={handleError}
    />
  );
};

export default SafeImage;

// ==========================================================================
// 4. COMPONENTE DE GALERIA DE IMAGENS - FRONTEND
// ==========================================================================

// Arquivo: client/src/components/ProductGallery.jsx
import React, { useState, useEffect } from 'react';
import SafeImage from './SafeImage';

const ProductGallery = ({ productId }) => {
  const [images, setImages] = useState([]);
  const [selectedImageId, setSelectedImageId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!productId) return;
    
    const fetchImages = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/products/${productId}/images`);
        
        if (!response.ok) {
          throw new Error('Falha ao carregar imagens');
        }
        
        const data = await response.json();
        
        if (data.success && data.images && data.images.length > 0) {
          setImages(data.images);
          
          // Selecionar a imagem principal por padrão
          const primaryImage = data.images.find(img => img.is_primary) || data.images[0];
          setSelectedImageId(primaryImage.id);
        } else {
          setImages([]);
          setSelectedImageId(null);
        }
      } catch (err) {
        console.error('Erro ao buscar imagens:', err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchImages();
  }, [productId]);

  // Renderizar um placeholder durante o carregamento
  if (loading) {
    return (
      <div className="product-gallery animate-pulse">
        <div className="main-image bg-gray-200 w-full h-64 rounded"></div>
        <div className="thumbnails flex mt-2 space-x-2">
          {[1, 2, 3].map(i => (
            <div key={i} className="bg-gray-200 w-16 h-16 rounded"></div>
          ))}
        </div>
      </div>
    );
  }

  // Renderizar mensagem de erro
  if (error) {
    return (
      <div className="product-gallery-error bg-red-50 p-4 rounded">
        <p className="text-red-500">Erro ao carregar imagens: {error}</p>
      </div>
    );
  }

  // Se não houver imagens, mostrar placeholder
  if (!images.length) {
    return (
      <div className="product-gallery-empty">
        <img 
          src="/placeholder-image.jpg" 
          alt="Imagem não disponível" 
          className="w-full h-64 object-contain bg-gray-100"
        />
      </div>
    );
  }

  return (
    <div className="product-gallery">
      {/* Imagem principal */}
      <div className="main-image relative h-64 bg-white rounded overflow-hidden">
        <SafeImage
          productId={productId}
          imageId={selectedImageId}
          alt="Imagem do produto"
          className="w-full h-full object-contain"
        />
      </div>
      
      {/* Miniaturas - mostrar apenas se houver mais de uma imagem */}
      {images.length > 1 && (
        <div className="thumbnails flex mt-2 space-x-2 overflow-x-auto">
          {images.map(image => (
            <div 
              key={image.id}
              className={`thumbnail-wrapper cursor-pointer w-16 h-16 rounded overflow-hidden border-2 ${
                selectedImageId === image.id ? 'border-primary' : 'border-transparent'
              }`}
              onClick={() => setSelectedImageId(image.id)}
            >
              <img
                src={image.thumbnail_url}
                alt="Miniatura"
                className="w-full h-full object-cover"
                onError={(e) => {
                  e.target.src = "/placeholder-image.jpg";
                }}
              />
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ProductGallery;

// ==========================================================================
// 5. CORREÇÃO DA PÁGINA DE RESERVAS - FRONTEND
// ==========================================================================

// Arquivo: client/src/pages/account/reservations.tsx

// ❌ CÓDIGO COM ERRO (REMOVER):
/*
<img 
  data-replit-metadata="client/src/pages/account/reservations.tsx:227:26" 
  data-component-name="img" 
  src="/uploads/stores/1/products/2/1746417794591-24235190.jpg" 
  alt="Máscara Buda Sidarta" 
  className="w-full h-full object-cover"
/>
*/

// ✅ CÓDIGO CORRETO (IMPLEMENTAR):
import SafeImage from '../../components/SafeImage';

// Dentro do componente de lista de reservas:
<SafeImage
  productId={reservation.product_id}
  alt={reservation.product_name}
  className="w-full h-full object-cover"
/>

// Alternativamente, para uma galeria completa:
import ProductGallery from '../../components/ProductGallery';

// Dentro do componente de detalhe da reserva:
<ProductGallery productId={reservation.product_id} />

// ==========================================================================
// 6. SCRIPT DE MIGRAÇÃO (SE NECESSÁRIO)
// ==========================================================================

// Script para recriar caminhos de imagens que estejam incorretos:
// Este script pode ser executado uma vez para corrigir caminhos existentes

import { pool } from '../db';
import path from 'path';
import fs from 'fs';

async function validateAndFixImagePaths() {
  console.log('Iniciando verificação e correção de caminhos de imagens...');
  
  try {
    // 1. Verificar imagens de produtos
    const productImagesQuery = `
      SELECT pi.id, pi.product_id, pi.image_url, pi.thumbnail_url, p.store_id
      FROM product_images pi
      JOIN products p ON pi.product_id = p.id
    `;
    
    const productImagesResult = await pool.query(productImagesQuery);
    console.log(`Encontradas ${productImagesResult.rows.length} imagens de produtos para verificar`);
    
    let fixedCount = 0;
    let errorCount = 0;
    
    for (const image of productImagesResult.rows) {
      try {
        // Verificar se o caminho segue o padrão seguro
        const imageUrl = image.image_url;
        const thumbnailUrl = image.thumbnail_url;
        
        const storeId = image.store_id;
        const productId = image.product_id;
        
        // Padrão seguro: /uploads/stores/{storeId}/products/{productId}/...
        const securePattern = new RegExp(`^/uploads/stores/${storeId}/products/${productId}/`);
        
        if (!securePattern.test(imageUrl)) {
          console.log(`Imagem ${image.id} tem caminho inseguro: ${imageUrl}`);
          
          // Obter o nome do arquivo do caminho atual
          const fileName = path.basename(imageUrl);
          const thumbFileName = path.basename(thumbnailUrl);
          
          // Criar novos caminhos seguros
          const newImageUrl = `/uploads/stores/${storeId}/products/${productId}/${fileName}`;
          const newThumbUrl = `/uploads/stores/${storeId}/products/${productId}/${thumbFileName}`;
          
          // Verificar/criar diretórios
          const uploadsDir = path.join(process.cwd(), 'public', 'uploads', 'stores', String(storeId), 'products', String(productId));
          
          if (!fs.existsSync(uploadsDir)) {
            fs.mkdirSync(uploadsDir, { recursive: true });
          }
          
          // Copiar arquivos para novos locais
          const oldImagePath = path.join(process.cwd(), 'public', imageUrl);
          const oldThumbPath = path.join(process.cwd(), 'public', thumbnailUrl);
          
          const newImagePath = path.join(process.cwd(), 'public', newImageUrl);
          const newThumbPath = path.join(process.cwd(), 'public', newThumbUrl);
          
          if (fs.existsSync(oldImagePath)) {
            fs.copyFileSync(oldImagePath, newImagePath);
          }
          
          if (fs.existsSync(oldThumbPath)) {
            fs.copyFileSync(oldThumbPath, newThumbPath);
          }
          
          // Atualizar registros no banco de dados
          await pool.query(`
            UPDATE product_images
            SET image_url = $1, thumbnail_url = $2
            WHERE id = $3
          `, [newImageUrl, newThumbUrl, image.id]);
          
          fixedCount++;
        }
      } catch (err) {
        console.error(`Erro ao processar imagem ${image.id}:`, err);
        errorCount++;
      }
    }
    
    console.log(`
      Verificação concluída:
      - ${fixedCount} imagens corrigidas
      - ${errorCount} erros encontrados
      - ${productImagesResult.rows.length - fixedCount - errorCount} imagens já estavam corretas
    `);
    
  } catch (error) {
    console.error('Erro durante a verificação de imagens:', error);
  }
}

// Execute apenas se necessário
// validateAndFixImagePaths();

// ==========================================================================
// INSTRUÇÕES PARA IMPLEMENTAÇÃO:
// ==========================================================================
//
// 1. Crie os componentes frontend (SafeImage.jsx e ProductGallery.jsx)
// 2. Crie o controller de imagens (image.controller.js)
// 3. Adicione as rotas de API para imagens
// 4. Modifique a página de reservas para usar o componente SafeImage
// 5. Execute o script de migração se necessário para corrigir caminhos existentes
//
// Depois disso, todas as imagens serão exibidas usando a API segura!