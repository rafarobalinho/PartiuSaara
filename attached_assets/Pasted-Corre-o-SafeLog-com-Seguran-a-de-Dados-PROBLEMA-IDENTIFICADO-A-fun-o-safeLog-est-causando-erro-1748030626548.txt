Corre√ß√£o SafeLog com Seguran√ßa de Dados
üö® PROBLEMA IDENTIFICADO
A fun√ß√£o safeLog est√° causando erro Console.js:61 e h√° risco de vazamento de dados sens√≠veis entre lojistas.
üõ°Ô∏è SOLU√á√ÉO SEGURA
1. CORRIGIR E PROTEGER FUN√á√ÉO DE LOG
Substitua sua fun√ß√£o safeLog por esta vers√£o segura:
typescript// Fun√ß√£o de log segura com prote√ß√£o de dados sens√≠veis
const secureLog = (message: string, data?: any, userId?: string) => {
  try {
    // Verificar se estamos em modo de desenvolvimento
    const isDev = process.env.NODE_ENV === 'development';
    const isTestMode = process.env.STRIPE_MODE === 'test';
    
    // S√≥ fazer log detalhado em desenvolvimento
    if (!isDev && !isTestMode) {
      // Em produ√ß√£o, log m√≠nimo sem dados sens√≠veis
      console.log(`[${new Date().toISOString()}] ${message}`);
      return;
    }

    // Em desenvolvimento, fazer log com dados sanitizados
    if (data) {
      const sanitizedData = sanitizeLogData(data, userId);
      console.log(`[${new Date().toISOString()}] ${message}`, sanitizedData);
    } else {
      console.log(`[${new Date().toISOString()}] ${message}`);
    }
  } catch (error) {
    // Log de fallback sem dados sens√≠veis
    try {
      console.error(`[LOG_ERROR] ${message} - Failed to log safely`);
    } catch {
      // Silencioso se tudo falhar
    }
  }
};

// Fun√ß√£o para sanitizar dados sens√≠veis
const sanitizeLogData = (data: any, userId?: string): any => {
  if (!data || typeof data !== 'object') {
    return data;
  }

  const sensitiveFields = [
    'password', 'token', 'secret', 'key', 'authorization',
    'cpf', 'cnpj', 'rg', 'phone', 'email', 'address',
    'latitude', 'longitude', 'coordinates', 'location',
    'price', 'cost', 'revenue', 'financial', 'payment',
    'stripe_customer_id', 'stripe_account_id'
  ];

  const sanitized = Array.isArray(data) ? [] : {};

  for (const [key, value] of Object.entries(data)) {
    const keyLower = key.toLowerCase();
    
    // Remover campos sens√≠veis
    if (sensitiveFields.some(field => keyLower.includes(field))) {
      sanitized[key] = '[PROTECTED]';
    }
    // Sanitizar objetos aninhados
    else if (value && typeof value === 'object') {
      sanitized[key] = sanitizeLogData(value, userId);
    }
    // Manter dados n√£o sens√≠veis
    else {
      sanitized[key] = value;
    }
  }

  // Adicionar identificador do usu√°rio para debug (sem dados pessoais)
  if (userId && !Array.isArray(sanitized)) {
    sanitized['_debug_user_hash'] = hashUserId(userId);
  }

  return sanitized;
};

// Fun√ß√£o para criar hash an√¥nimo do usu√°rio
const hashUserId = (userId: string): string => {
  try {
    // Criar hash simples para identifica√ß√£o de debug sem expor ID real
    return `user_${userId.slice(-4)}${Date.now().toString().slice(-3)}`;
  } catch {
    return 'user_unknown';
  }
};
2. IMPLEMENTAR AUTENTICA√á√ÉO E AUTORIZA√á√ÉO SEGURA
typescript// Fun√ß√£o para extrair e validar usu√°rio da requisi√ß√£o
const extractUserFromRequest = async (req: Request): Promise<{ userId: string; isLojista: boolean } | null> => {
  try {
    // Extrair token do header Authorization
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return null;
    }

    const token = authHeader.replace('Bearer ', '');
    
    // Validar token (substitua pela sua l√≥gica de valida√ß√£o)
    const decoded = await validateJWTToken(token); // Implementar esta fun√ß√£o
    
    if (!decoded || !decoded.userId) {
      return null;
    }

    // Verificar se √© lojista
    const user = await getUserById(decoded.userId); // Implementar esta fun√ß√£o
    
    return {
      userId: decoded.userId,
      isLojista: user?.type === 'lojista' || user?.role === 'seller'
    };

  } catch (error) {
    secureLog('‚ùå Erro na autentica√ß√£o', null);
    return null;
  }
};

// Fun√ß√£o para validar propriedade de dados
const validateDataOwnership = async (userId: string, dataType: string, dataId?: string): Promise<boolean> => {
  try {
    // Implementar valida√ß√£o espec√≠fica por tipo de dado
    switch (dataType) {
      case 'store':
        return dataId ? await isStoreOwner(userId, dataId) : true;
      case 'product':
        return dataId ? await isProductOwner(userId, dataId) : true;
      case 'subscription':
        return await isSubscriptionOwner(userId);
      default:
        return false;
    }
  } catch (error) {
    secureLog('‚ùå Erro na valida√ß√£o de propriedade', null, userId);
    return false;
  }
};
3. ENDPOINT STRIPE SEGURO
typescriptexport const createCheckoutSession = async (req: Request, res: Response) => {
  const startTime = Date.now();
  let currentUser: { userId: string; isLojista: boolean } | null = null;

  try {
    secureLog('üöÄ Stripe checkout iniciado');

    // CHECKPOINT 1: Validar m√©todo
    if (req.method !== 'POST') {
      secureLog('‚ùå M√©todo n√£o permitido', { method: req.method });
      return res.status(405).json({ error: 'Method not allowed' });
    }

    // CHECKPOINT 2: Autenticar usu√°rio
    currentUser = await extractUserFromRequest(req);
    if (!currentUser) {
      secureLog('‚ùå Usu√°rio n√£o autenticado');
      return res.status(401).json({ error: 'Authentication required' });
    }

    // CHECKPOINT 3: Verificar se √© lojista
    if (!currentUser.isLojista) {
      secureLog('‚ùå Acesso negado - n√£o √© lojista', null, currentUser.userId);
      return res.status(403).json({ error: 'Access denied - seller account required' });
    }

    secureLog('‚úÖ Usu√°rio autenticado como lojista', null, currentUser.userId);

    // CHECKPOINT 4: Validar dados da requisi√ß√£o
    const { planId, interval } = req.body;
    
    if (!planId) {
      secureLog('‚ùå Plan ID ausente', null, currentUser.userId);
      return res.status(400).json({ error: 'Plan ID is required' });
    }

    // CHECKPOINT 5: Validar se pode fazer upgrade/downgrade
    const canChangePlan = await validatePlanChange(currentUser.userId, planId);
    if (!canChangePlan) {
      secureLog('‚ùå Mudan√ßa de plano n√£o permitida', { planId }, currentUser.userId);
      return res.status(403).json({ error: 'Plan change not allowed' });
    }

    // CHECKPOINT 6: Configurar Stripe
    const isTestMode = process.env.STRIPE_MODE === 'test';
    const stripeSecretKey = isTestMode 
      ? process.env.STRIPE_SECRET_KEY_TEST 
      : process.env.STRIPE_SECRET_KEY_LIVE;

    if (!stripeSecretKey) {
      secureLog('‚ùå Configura√ß√£o Stripe ausente', null, currentUser.userId);
      return res.status(500).json({ error: 'Payment system configuration error' });
    }

    const Stripe = require('stripe');
    const stripe = new Stripe(stripeSecretKey, { apiVersion: '2023-10-16' });

    // CHECKPOINT 7: Mapear Price IDs (SUBSTITUA PELOS SEUS)
    const priceMapping = {
      freemium: null,
      start: {
        monthly: isTestMode ? 'price_TEST_START_MONTHLY' : 'price_LIVE_START_MONTHLY',
        yearly: isTestMode ? 'price_TEST_START_YEARLY' : 'price_LIVE_START_YEARLY'
      },
      pro: {
        monthly: isTestMode ? 'price_TEST_PRO_MONTHLY' : 'price_LIVE_PRO_MONTHLY',
        yearly: isTestMode ? 'price_TEST_PRO_YEARLY' : 'price_LIVE_PRO_YEARLY'
      },
      premium: {
        monthly: isTestMode ? 'price_TEST_PREMIUM_MONTHLY' : 'price_LIVE_PREMIUM_MONTHLY',
        yearly: isTestMode ? 'price_TEST_PREMIUM_YEARLY' : 'price_LIVE_PREMIUM_YEARLY'
      }
    };

    if (planId === 'freemium') {
      // Ativar plano gratuito
      await updateUserPlan(currentUser.userId, 'freemium');
      secureLog('‚úÖ Plano freemium ativado', null, currentUser.userId);
      
      return res.status(200).json({ 
        success: true, 
        message: 'Freemium plan activated',
        redirect: false
      });
    }

    const priceId = priceMapping[planId]?.[interval || 'monthly'];
    if (!priceId) {
      secureLog('‚ùå Price ID n√£o encontrado', { planId, interval }, currentUser.userId);
      return res.status(400).json({ error: 'Invalid plan configuration' });
    }

    // CHECKPOINT 8: Criar sess√£o Stripe
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price: priceId,
        quantity: 1,
      }],
      mode: 'subscription',
      success_url: `${process.env.NEXT_PUBLIC_APP_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/pricing`,
      client_reference_id: currentUser.userId, // Para identificar o usu√°rio no webhook
      metadata: {
        userId: currentUser.userId,
        planId,
        interval: interval || 'monthly',
        userType: 'lojista'
      },
    });

    // CHECKPOINT 9: Log de sucesso (sem dados sens√≠veis)
    const processingTime = Date.now() - startTime;
    secureLog('‚úÖ Sess√£o Stripe criada', { 
      sessionId: session.id.slice(-8) + '...', // Apenas parte do ID
      processingTime: `${processingTime}ms`,
      planId 
    }, currentUser.userId);

    return res.status(200).json({
      success: true,
      url: session.url,
      sessionId: session.id // Frontend precisa do ID completo
    });

  } catch (error) {
    const processingTime = Date.now() - startTime;
    
    secureLog('‚ùå Erro no checkout Stripe', {
      error: error.message,
      type: error.type,
      processingTime: `${processingTime}ms`
    }, currentUser?.userId);

    return res.status(500).json({
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error.message : 'Payment processing failed'
    });
  }
};
4. FUN√á√ïES DE VALIDA√á√ÉO (IMPLEMENTAR CONFORME SEU BANCO)
typescript// Implementar estas fun√ß√µes conforme sua estrutura de banco de dados

const validateJWTToken = async (token: string): Promise<{ userId: string } | null> => {
  // Implementar valida√ß√£o de JWT
  // return jwt.verify(token, process.env.JWT_SECRET);
  throw new Error('Implementar valida√ß√£o JWT');
};

const getUserById = async (userId: string): Promise<{ type: string; role: string } | null> => {
  // Implementar busca no banco
  // return await db.user.findById(userId);
  throw new Error('Implementar busca de usu√°rio');
};

const isStoreOwner = async (userId: string, storeId: string): Promise<boolean> => {
  // Verificar se o usu√°rio √© dono da loja
  // return await db.store.findOne({ id: storeId, ownerId: userId });
  throw new Error('Implementar valida√ß√£o de propriedade da loja');
};

const isProductOwner = async (userId: string, productId: string): Promise<boolean> => {
  // Verificar se o usu√°rio √© dono do produto
  // return await db.product.findOne({ id: productId, sellerId: userId });
  throw new Error('Implementar valida√ß√£o de propriedade do produto');
};

const isSubscriptionOwner = async (userId: string): Promise<boolean> => {
  // Verificar propriedade da assinatura
  return true; // Implementar valida√ß√£o
};

const validatePlanChange = async (userId: string, newPlan: string): Promise<boolean> => {
  // Implementar l√≥gica de valida√ß√£o de mudan√ßa de plano
  return true; // Por enquanto permitir todas
};

const updateUserPlan = async (userId: string, plan: string): Promise<void> => {
  // Implementar atualiza√ß√£o do plano no banco
  // await db.user.update({ id: userId }, { plan });
};
üéØ PR√ìXIMOS PASSOS

Substituir sua fun√ß√£o safeLog pela secureLog
Implementar as fun√ß√µes de valida√ß√£o conforme seu banco de dados
Testar com logs seguros
Substituir os Price IDs pelos reais
Validar isolamento entre lojistas