SOLU√á√ÉO DE EMERG√äNCIA: Corrigir erro cr√≠tico "Unexpected token '<': '<!DOCTYPE...' is not valid JSON"
Este √© um erro cr√≠tico que est√° bloqueando completamente o uso do aplicativo. Precisamos de uma solu√ß√£o IMEDIATA.
O QUE EST√Å ACONTECENDO:
O frontend est√° recebendo HTML em vez de JSON quando tenta buscar produtos, causando o erro Unexpected token '<': '<!DOCTYPE...' is not valid JSON. Isto indica que:

O servidor est√° retornando uma p√°gina HTML de erro
O frontend est√° tentando interpretar isso como JSON
A aplica√ß√£o quebra completamente

INSTRU√á√ïES DETALHADAS:
PARTE 1: FRONTEND - TRATAMENTO B√ÅSICO DE ERRO (CORRE√á√ÉO IMEDIATA)
Localize o arquivo que faz a chamada para listar produtos (provavelmente HomeScreen.js, ProductsList.js ou similar) e SUBSTITUA o c√≥digo de busca de produtos por este:
javascript// COPIE ESTE C√ìDIGO EXATAMENTE COMO EST√Å - SEM MODIFICA√á√ïES
import React, { useState, useEffect } from 'react';
import axios from 'axios';

// ... resto do seu componente

// SUBSTITUA seu useEffect atual por este:
useEffect(() => {
  const fetchProducts = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // URL da API - AJUSTE PARA SUA ROTA CORRETA
      const url = '/api/products'; // ou qualquer rota que voc√™ use
      
      // Fazer a chamada com tratamento expl√≠cito para resposta n√£o-JSON
      const response = await fetch(url)
        .then(async res => {
          // Verificar tipo de conte√∫do da resposta
          const contentType = res.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            // N√£o √© JSON - retornar um objeto JSON padr√£o para evitar erro
            return { 
              products: [], 
              error: "Resposta inv√°lida do servidor" 
            };
          }
          
          // √â JSON - processar normalmente
          return res.json();
        })
        .catch(err => {
          // Capturar erros de rede ou parsing
          console.error("Erro ao processar resposta:", err);
          return { 
            products: [], 
            error: "Erro ao processar dados do servidor" 
          };
        });
      
      // Verificar formato da resposta e atualizar o estado
      if (response.products) {
        setProducts(response.products);
      } else if (Array.isArray(response)) {
        setProducts(response);
      } else {
        setProducts([]);
        setError(response.error || "Formato de resposta inesperado");
      }
    } catch (error) {
      console.error("Erro na requisi√ß√£o:", error);
      setProducts([]);
      setError("N√£o foi poss√≠vel carregar os produtos. Tente novamente mais tarde.");
    } finally {
      setLoading(false);
    }
  };
  
  fetchProducts();
}, [categoryId]); // Ajuste as depend√™ncias conforme necess√°rio

// Na parte do render, adicione isso no seu JSX:
return (
  <div>
    {loading ? (
      <div className="flex justify-center p-10">
        <div className="w-12 h-12 border-t-4 border-orange-500 rounded-full animate-spin"></div>
      </div>
    ) : error ? (
      <div className="text-center p-6 bg-white rounded-lg shadow-sm">
        <div className="text-orange-500 text-5xl mb-3">‚ö†Ô∏è</div>
        <h3 className="text-lg font-medium">N√£o encontramos produtos</h3>
        <p className="text-sm text-gray-500 mb-4">{error}</p>
        <button
          className="px-4 py-2 bg-orange-500 text-white rounded-md"
          onClick={() => window.location.reload()}
        >
          Limpar Filtros e Tentar Novamente
        </button>
      </div>
    ) : products.length === 0 ? (
      <div className="text-center p-6 bg-white rounded-lg shadow-sm">
        <div className="text-gray-400 text-5xl mb-3">üîç</div>
        <h3 className="text-lg font-medium">N√£o encontramos produtos para esta categoria</h3>
        <p className="text-sm text-gray-500 mb-4">Tente outra categoria ou volte mais tarde.</p>
        <button
          className="px-4 py-2 bg-orange-500 text-white rounded-md"
          onClick={() => window.location.href = '/'}
        >
          Voltar para a p√°gina inicial
        </button>
      </div>
    ) : (
      // Renderiza√ß√£o normal dos produtos
      <div className="grid grid-cols-2 gap-3">
        {products.map(product => (
          // Seu componente ProductCard aqui
        ))}
      </div>
    )}
  </div>
);
PARTE 2: BACKEND - CORRE√á√ÉO DO ENDPOINT DE PRODUTOS
Localize o arquivo de rotas da API no servidor que lida com produtos (provavelmente em routes/products.js, controllers/products.js ou similar) e SUBSTITUA o endpoint por este:
javascript// COPIE ESTE C√ìDIGO EXATAMENTE COMO EST√Å - SEM MODIFICA√á√ïES
// Endpoint para listar produtos (geral ou por categoria)
app.get('/api/products', async (req, res) => {
  try {
    // Par√¢metros de filtro
    const { category, categoryId, categorySlug } = req.query;
    
    let query = 'SELECT * FROM products WHERE is_active = true';
    let params = [];
    
    // Adicionar filtro por categoria se fornecido
    if (categoryId) {
      query += ' AND (category_id = $1 OR $1 = ANY(secondary_categories))';
      params.push(categoryId);
    } else if (categorySlug) {
      // Se tiver slug da categoria, primeiro encontrar o ID
      const categoryQuery = 'SELECT id FROM categories WHERE slug = $1';
      const categoryResult = await pool.query(categoryQuery, [categorySlug]);
      
      if (categoryResult.rows.length > 0) {
        const catId = categoryResult.rows[0].id;
        query += ' AND (category_id = $1 OR $1 = ANY(secondary_categories))';
        params.push(catId);
      }
    } else if (category) {
      // Se tiver nome da categoria
      query += ' AND (category = $1 OR $1 = ANY(secondary_categories))';
      params.push(category);
    }
    
    query += ' ORDER BY created_at DESC';
    
    const { rows } = await pool.query(query, params);
    
    // SEMPRE retornar um JSON v√°lido
    return res.json({ 
      products: rows,
      count: rows.length,
      filters: { category, categoryId, categorySlug }
    });
  } catch (error) {
    console.error('Erro ao buscar produtos:', error);
    
    // SEMPRE retornar um JSON v√°lido, mesmo em caso de erro
    return res.status(500).json({ 
      products: [],
      error: 'Erro ao buscar produtos',
      message: error.message
    });
  }
});

// Endpoint espec√≠fico para produtos por categoria
app.get('/api/categories/:slug/products', async (req, res) => {
  try {
    const { slug } = req.params;
    
    // Primeiro buscar o ID da categoria
    const categoryQuery = 'SELECT id FROM categories WHERE slug = $1';
    const categoryResult = await pool.query(categoryQuery, [slug]);
    
    if (categoryResult.rows.length === 0) {
      // Categoria n√£o encontrada - retornar array vazio, n√£o erro
      return res.json({ 
        products: [],
        count: 0,
        message: 'Categoria n√£o encontrada'
      });
    }
    
    const categoryId = categoryResult.rows[0].id;
    
    // Buscar produtos da categoria
    const productsQuery = `
      SELECT * FROM products 
      WHERE (category_id = $1 OR $1 = ANY(secondary_categories))
      AND is_active = true
      ORDER BY created_at DESC
    `;
    
    const { rows } = await pool.query(productsQuery, [categoryId]);
    
    // SEMPRE retornar um JSON v√°lido
    return res.json({ 
      products: rows,
      count: rows.length,
      categorySlug: slug
    });
  } catch (error) {
    console.error('Erro ao buscar produtos por categoria:', error);
    
    // SEMPRE retornar um JSON v√°lido, mesmo em caso de erro
    return res.status(500).json({ 
      products: [],
      error: 'Erro ao buscar produtos',
      message: error.message
    });
  }
});
VERIFICA√á√ÉO CR√çTICA
Depois de implementar as solu√ß√µes acima, verifique:

Se o seu banco de dados tem a estrutura necess√°ria (tabelas products, categories)
Se as rotas da API est√£o corretamente definidas no seu servidor
Se o frontend est√° importando e usando corretamente o useState e useEffect

Se o problema persistir, IMPLEMENTE ESTE INTERCEPTOR DE AXIOS como √∫ltimo recurso:
javascript// Arquivo: src/api.js ou onde voc√™ configura o axios
import axios from 'axios';

const api = axios.create({
  baseURL: '/api'
});

// Interceptor para tratar respostas HTML como erro
api.interceptors.response.use(
  response => response,
  error => {
    // Se a resposta cont√©m HTML em vez de JSON
    if (error.response && 
        error.response.data && 
        typeof error.response.data === 'string' && 
        error.response.data.includes('<!DOCTYPE')) {
      
      console.error('Recebeu HTML em vez de JSON:', error.response.data.substring(0, 100));
      
      // Substitui o erro por um objeto de erro amig√°vel
      return Promise.reject({ 
        response: { 
          status: 500, 
          data: { 
            products: [],
            error: 'O servidor retornou uma resposta inv√°lida',
            message: 'Tente novamente mais tarde'
          } 
        } 
      });
    }
    
    return Promise.reject(error);
  }
);

export default api;
IMPORTANTE: Aplique estas mudan√ßas EXATAMENTE como est√£o. N√£o modifique o c√≥digo. Este √© um problema cr√≠tico de tratamento de erro e precisa ser resolvido imediatamente para que os usu√°rios possam usar o aplicativo.